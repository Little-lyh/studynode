# Task2 #

## 什么是CSS？HTML、CSS、JavaScript三者之间的关系是什么 ##

### 什么是CSS ###

​		CSS是**层叠样式表**（Cascading Style Sheets）的简称。样式，顾名思义就是定义如何显示HTML元素，样式通常存储在样式表中。

​		网页HTML中大量使用div、span、table表格等标签布局，要实现漂亮的布局（CSS宽度、CSS高度、CSS背景、CSS字体大小等样式）我们就需要CSS样式实现。同样的一组DIV标签，对应CSS样式代码不同，所得到效果也不同。我们可以比作HTML是骨架，CSS是衣服。相同HTML骨架结构，不同CSS样式，所得到的美化布局效果不同。



### HTML、CSS、JavaScript三者之间的关系 ###

​		打个比方，如果说HTML是人的血肉，那么CSS就决定你这个人的身高、体重、长相，也就是你这个人的魅力，JavaScript就相当于你的灵魂。没有JavaScript，这个网页就是一个长得很好看的植物人；没有JavaScript和CSS，网页就是一个普通的甚至有点毁容的植物人。

​		

## HTML中引入CSS的方式有哪几种？三者的优先级是怎样的？分别举例说明这三种方式 ###

### HTML中引入CSS的方法 ###

+ **内联方式**

  内联方式是指在HTML标签中使用`style`属性添加CSS。这种方式没有体现CSS的优势，所以不推荐使用。

  ```
  <div style="width:100px;height:100px;">内联方式</div>
  ```

  

+ **嵌入方法**

  嵌入方法是在HTML的头部中使用style标签写如CSS样式

  ```
  <head>
      <style>
      .content {
          background: red;
      }
      </style>
  </head>
  ```

  嵌入方式的 CSS 只对当前的网页有效。因为 CSS 代码是在 HTML 文件中，所以会使得代码比较集中，当我们写模板网页时这通常比较有利。因为查看模板代码的人可以一目了然地查看 HTML 结构和 CSS 样式。因为嵌入的 CSS 只对当前页面有效，所以当多个页面需要引入相同的 CSS 代码时，这样写会导致代码冗余，也不利于维护。

+ **外部样式**

  	+  **链接方法**

  链接方法是在HTML中的<head>标签下引入外部的CSS文件

  ```
  <head>
  	<link rel="stylesheet" type="text/css" href="css.css">
  </head>
  ```

  使用链接式时与导入式不同的是它会以网页文件主体装载前装载CSS文件，因此显示出来的网页从一开始就是带样式的效果的，它不会象导入式那样先显示无样式的网页，然后再显示有样式的网页，这是链接式的优点。

  	+ **导入方式**

  导入方式是指使用CSS规则引入外部的CSS文件。

  ```
  <style type="text/css">
  	@import url(css.css);
  </style>
  ```

  导入式会在整个网页装载完后再装载CSS文件，因此这就导致了一个问题，如果网页比较大则会儿出现先显示无样式的页面，闪烁一下之后，再出现网页的样式。这是导入式固有的一个缺陷。

  **链接式和导入式的区别**

     <link>
          1、属于XHTML
          2、优先加载CSS文件到页面
      @import
          1、属于CSS2.1
          2、先加载HTML结构在加载CSS文件。

  

​		一般来说，做网站时把样式多写在多个样式表文件中，因此我们先用链接式引入一个总的CSS文件，然后在这个CSS文件中在使用导入式来引入其他的CSS文件。但如果通过JavaScrip来动态引入CSS文件则只能使用链接式。



### 四种CSS引入方式的优先级 ###

+ 就近原则
+ 理论上：内联>嵌入>链接>导入
+ 实际上：内联、链接、导入在同一个文件头部，谁李相应的代码进，谁的优先级就高



## CSS 选择器有哪几种方式？优先级是怎么样的？分别举例说明这些方式 ###

### CSS选择器有哪几种方式 ###

+ **简单选择器Simple Selectors**

  | 选择器  | 含义                                           |
  | ------- | ---------------------------------------------- |
  | *       | 通用元素选择器，匹配任何元素                   |
  | E       | 标签选择器，匹配所有使用E标签的元素            |
  | .info   | class选择器，匹配所有class属性中包含info的元素 |
  | #footer | id选择器，匹配所有id属性等于footer的元素       |

  **1、*选择器**

  ```
   {
    margin: 0;
    padding: 0;
  }
  ```

  在我们看比较高级的选择器之前，应该认识下这个众所周知的清空选择器。星号呢会将页面上所有每一个元素都选到。许多开发者都用它来清空margin和padding。当然你在练习的时候使用这个没问题，但是我不建议在生产环境中使用它。它会给浏览器凭添许多不必要的东西。*也可以用来选择某元素的所有子元素。

  ```
  #container * {
    border: 1px solid black;
  }
  ```

  它会选中#container下的所有元素。当然，我还是不建议你去使用它，如果可能的话。

  

  **2、#X**

  ```
  #container {
     width: 960px;
     margin: auto;
  }
  ```

  在选择器中使用#可以用id来定位某个元素。大家通常都会这么使用，然后使用的时候大家还是得相当小心的。需要问自己一下：我是不是必须要给这个元素来赋值个id来定位它呢？

  id选择器是很严格的并且你没办法去复用它。如果可能的话，首先试试用标签名字，HTML5中的新元素，或者是伪类。

  

  **3、.X**

  ```
  .error {
    color: red;
  }
  ```

  这是个class选择器。它跟id选择器不同的是，它可以定位多个元素。当你想对多个元素进行样式修饰的时候就可以使用class。当你要对某个特定的元素进行修饰那就是用id来定位它。

  

  **4、X**

  ```
  a { color: red; }
  ul { margin-left: 0; }
  ```

  如果你想定位页面上所有的某标签，不是通过id或者是’class’，这简单，直接使用类型选择器。

  

  优先级别

  > id>class>元素

+ **属性选择器 Attribute Selectors**

  | 选择器       | 含义                                               |
  | ------------ | -------------------------------------------------- |
  | [atrr]       | 选择包含 attr 属性的所有元素，不论 attr 的值为何   |
  | [attr=val]   | [attr=val] 仅选择 attr 属性被赋值为 val 的所有元素 |
  | [atrr~=val]  | 选择 titile 属性包含单词val的元素                  |
  | [atrr\|=val] | 选择 attr 属性值以val开头的元素                    |

  **1、[atrr]**

  ```
  a[title] {
    color: green;
  }
  ```

  上面的这个例子中，只会选择有title属性的元素。那些没有此属性的锚点标签将不会被这个代码修饰。

  **2、[atrr=val]**

  ```
  a[href="http://www.baidu.com"] {
    color: #1f6053; /* nettuts green */
  }
  ```

  上面这片代码将会把href属性值为http://www.baidu.com的锚点标签设置为绿色，而其他标签则不受影响。

  > 注意我们将值用双引号括起来了。那么在使用Javascript的时候也要使用双引号括起来。可以的话，尽量使用标准的CSS3选择器。

  这样可以用了，但是还是有点死，如果不是这个链接，而是类似的链接，那么这时就得用正则表达式了。

  **3、[attr~=val]**

  ```
  [title~=flower]
  { 
  background-color:yellow;
  }
  ```

  **4、[attr|=val]**

  ```
  [lang|=en]
  { 
  background-color:yellow;
  }
  ```

+ **组合选择器 Combinators**

  | 选择器 | 含义                                     |
  | ------ | ---------------------------------------- |
  | A，B   | 选中匹配A或/和B的元素                    |
  | A B    | 选中B且为匹配A的元素的后代元素           |
  | A > B  | 选中匹配B且为匹配A的元素的直接子元素     |
  | A+B    | 选中匹配B且为匹配A的元素的额下一相邻元素 |
  | A~B    | 选中匹配B且为匹配A的元素的下N个相邻元素  |

  **1、A B **

  ```
  li a {
    text-decoration: none;
  }
  ```

  下一个常用的就是descendant选择器。如果你想更加具体的去定位元素，你可以使用它。例如，假如，你不需要定位所有的a元素，而只需要定位li标签下的a标签？这时候你就需要使用descendant选择器了。

  专家提示：如果你的选择器像X Y Z A B.error这样，那你就错了。时刻都提醒自己，是否真的需要对那么多元素修饰。

  

  **2、A+B**

  ```
  ul + p {
     color: red;
  }
  ```

  这个叫相邻选择器。它指挥选中指定元素的直接后继元素。上面那个例子就是选中了所有ul标签后面的第一段，并将它们的颜色都设置为红色。

  

  **3、A>B **

  ```
  div#container > ul {
    border: 1px solid black;
  }
  ```

  A B和A > B的差别就是后面这个指挥选择它的直接子元素。看下面的例子：

  ```
  <div id="container">
     <ul>
        <li> List Item
          <ul>
             <li> Child </li>
          </ul>
        </li>
        <li> List Item </li>
        <li> List Item </li>
        <li> List Item </li>
     </ul>
  </div>
  ```

  \#container > ul只会选中id为’container’的div下的所有直接ul元素。它不会定位到如第一个li下的ul元素。

  由于某些原因，使用子节点组合选择器会在性能上有许多的优势。事实上，当在javascript中使用css选择器时候是强烈建议这么做的。

  

  **4、 A~B **

  ```
  ul ~ p {
    color: red;
  }
  ```

  兄弟节点组合选择器跟A+B很相似，然后它又不是那么的严格。ul + p选择器只会选择紧挨跟着指定元素的那些元素。而这个选择器，会选择跟在目标元素后面的所有匹配的元素。

  

  **5、A，B**

  选择并设置所有 <h1> 样式和所有 <p> 元素的样式：

  ```
  h1,p
  { 
  background-color:yellow;
  }
  ```

  

+ **伪类Pseudo-classes**

  | 选择器          | 含义                                           |
  | --------------- | ---------------------------------------------- |
  | a:link          | 匹配所有未被点击的链接                         |
  | a:visited       | 匹配所有已被点击的链接                         |
  | a:hover         | 匹配鼠标悬停其上的a元素                        |
  | a:active        | 匹配鼠标已经其上按下、还没有释放的a元素        |
  | li:first-child  | 匹配父元素的第一个子元素li                     |
  | li:last-child   | 匹配父元素的最后一个子元素li                   |
  | li:nth-child(n) | 匹配父元素的第n个子元素li（odd奇数，even偶数） |

  **1、X：visited and X:link **

  ```
  a:link {color:red;}
  a:visited {color: purple;}
  ```

  我们使用:link这个伪类来定位所有还没有被访问过的链接。

  另外，我们也使用:visited来定位所有已经被访问过的链接。

  

  **2、a:hover **

  ```
  div:hover {
    background: #e3e3e3;
  }
  ```

  不用说，大家肯定知道它。官方的说法是`user action pseudo class`.听起来有点儿迷糊，其实还好。如果想在用户鼠标飘过的地方涂点儿彩，那这个伪类写法可以办到。

  注意旧版本的IE只会对加在锚点`a`标签上的`:hover`伪类起作用。

  通常大家在鼠标飘过锚点链接时候加下边框的时候用到它。

  ```
  a:hover {
   border-bottom: 1px solid black;
  }
  ```

  专家提示：border-bottom:1px solid black;比text-decoration:underline;要好看很多

  

  **3、a:active**

  选择活动链接，并设置其样式：

  ```
  a:active
  { 
  background-color:yellow;
  }
  ```

  :active 选择器用于选择活动链接。

  当您在一个链接上点击时，它就会成为活动的（激活的）。

  **提示：**请使用 [:link]选择器对指向未被访问页面的链接设置样式，[:visited]用于设置指向已访问页面的链接的样式，[:hover]选择器用于设置鼠标指针浮动到链接上时的样式。

  

  **4、li:nth-child(n)**

  ```
  li:nth-child(3) {
     color: red;
  }
  ```

  还记得我们面对如何取到推跌式标签的第几个元素是无处下手的时光么，有了`nth-child`那日子就一去不复返了。

  请注意`nth-child`接受一个整形参数，然后它不是从0开始的。如果你想获取第二个元素那么你传的值就是`li:nth-child(2)`.

  我们甚至可以获取到由变量名定义的个数个子标签。例如我们可以用`li:nth-child(4n)`去每隔3个元素获取一次标签。

  **5、li:last-child**

  ```
  ul > li:last-child {
     color: green;
  }
  ```

  跟`first-child`相反，`last-child`取的是父标签的最后一个标签。

  例如
  标签

  ```
      List Item 
      List Item 
      List Item 
  ```

  这里没啥内容，就是一个了 List。

  ```
  ul {
   width: 200px;
   background: #292929;
   color: white;
   list-style: none;
   padding-left: 0;
  }
  li {
   padding: 10px;
   border-bottom: 1px solid black;
   border-top: 1px solid #3c3c3c;
  }
  ```

  上面的代码将设置背景色，移除浏览器默认的内边距，为每个`li`设置边框以凸显一定的深度。

  **6、X:first-child**

  ```
  ul li:first-child {
     border-top: none;
  }
  ```

  这个结构性的伪类可以选择到第一个子标签，你会经常使用它来取出第一个和最后一个的边框。

  假设有个列表，每个标签都有上下边框，那么效果就是第一个和最后一个就会看起来有点奇怪。这时候就可以使用这个伪类来处理这种情况了。

+ **伪元素Pseudo-elements**

  | 选择器          | 含义                                                         |
  | --------------- | ------------------------------------------------------------ |
  | E::before       | 在E元素内创建一个子元素，插入生成的内容作为伪元素，放在最前面 |
  | E::after        | 在E元素内创建一个子元素，插入生成的内容作为伪元素，放在最后面 |
  | E::selection    | 应用于文档中被用户高亮的部分（比如使用鼠标选中的部分）       |
  | E::first-letter | 匹配E元素的第一个字母第一行的第一个字母                      |
  | E::first-line   | 匹配E元素的第一行                                            |

  **1、E:after**

  `before`和`after`这俩伪类。好像每天大家都能找到使用它们的创造性方法。它们会在被选中的标签周围生成一些内容。
  当使用`.clear-fix`技巧时许多属性都是第一次被使用到里面的。

  ```
  .clearfix:after {
      content: "";
      display: block;
      clear: both;
      visibility: hidden;
      font-size: 0;
      height: 0;
    }
  .clearfix { 
     display: inline-block; 
     _height: 1%;
  }
  ```

  上面这段代码会在目标标签后面补上一段空白，然后将它清除。这个方法你一定得放你的聚宝盆里面。特别是当`overflow:hidden`方法不顶用的时候，这招就特别管用了。

  

  根据CSS3标准规定，可以使用两个冒号`::`。然后为了兼容性，浏览器也会接受一个双引号的写法。其实在这个情况下，用一个冒号还是比较明智的。

+ **多重选择器Multiple Select**

  在HTML中，我们有时会对同一个标签赋予多个class名称，如：

  ```
  <div class="one two"></div>
  ```

  而在CSS里面则可能同时选择多个class，像是：

  ```
  .one .two{}    /*两个 class 中有空格*/
  .one.two{}     /*两个 class 中沒有空格*/
  .one, .two{}   /*两个 class 中出现逗号*/
  ```

  这三者 `one.two{ }`，`.one .two{ }`，或者是`.one, .two{ }`有何区别？

  - 第一个的 one 和 two 中间包含空格，意思是指，我必须要是在 one 裡面的 two，才会被选择到。
  - 第二个的 one 和 two 中间没有包含空格，表示某个区块必须同时具有 one 和 two 的 class 时，才能被 CSS 所选择到到。
  - 第三个的 one 和 two 中间包含逗号，意思是指 class 中有 one 或 two，都会被编辑器所选择到。

  简单来说，没空格表示必须同时包含才会被选取；有空格表示后面的 class 被镶嵌在前面的 class 中才会被选取；逗号则表示只要有其中一个 class 就会被选取到 。



### CSS优先级 ###

​		**css优先级**，即是指CSS样式在浏览器中被解析的先后顺序

- 选择器优先级的规定

   关于优先级的规定，常用的方法是给不同的选择器分配权值： 

  - id选择器优先级很高，权值为100
  - class、属性和伪类选择器的权值为10
  - 标签选择器权值为1
     在比较样式的优先级时，只需统计选择符中的id、class和标签名的个数，然后把相应的权值相加即可，最后根据结果排出优先级
  - 权值较大的优先级越高
  - 权值相同的，后定义的优先级较高
  - 样式值含有！important，优先级最高

> div .class1 #people的权值等于1+10+100=111
>  .class2 li #age的权值等于10+1+100=111
>  如果第二个选择器后定义样式，则第二个的优先级要高

- 后代选择器的定位原则
   在这里介绍一下对于后代选择器，浏览器是如何查找元素的呢？
   **浏览器CSS匹配不是从左到右进行查找，而是从右到左进行查找。**
   比如DIV#divBox p span.red{color:red;}，浏览器的查找顺序如下：先查找html中所有class='red'的span元素，找到后，再查找其父辈元素中是否有p元素，再判断p的父元素中是否有id为divBox的div元素，如果都存在则匹配上。
   **浏览器从右到左进行查找的好处是为了尽早过滤掉一些无关的样式规则和元素。**



## CSS的盒子模型是怎么样的？ ##

### CSS盒子模型(Box Model) ###

​		简单地说每个html标签都是一个方块，然后这个方块又包着几个小方块。分别是：margin、border、padding、content。它们的关系是margin包着border包着padding包着content。就像盒子一层一层地包着一样，这就是我们所说的盒模型。

​		打开谷歌浏览器，按下F12，然后把右边栏的滚动条拉到最下面你就会看到一个东西：

​												![谷歌浏览器F12](C:\Users\Temton\AppData\Roaming\Typora\typora-user-images\1564036946186.png)  

​		这就很直观给我们展示了什么是盒子模型！

​		在CSS中，“box model”这一术语使用来说设计和布局时使用的。CSS和模型本质上是是一个盒子，封装周围的HTML元素，他包括：镖局，边框，填充和实际内容。

​		盒子模型允许我们在其他元素和周围元素边框之间的空间放置元素。

		+ Margin(外边距)： 清除边框外的区域，外边距是透明的。
		+ Border(边框)：围绕在内边距和内容外的边框。
		+ Padding(内边距)：清除内容周围的区域，内边距是透明的。
		+ Content(内容)：盒子的内容，显示文本和图像。



## 什么是[流式布局]？[流式布局]和[绝对定位布局]的优劣势在哪里,他们分别适用于那些场景？

### **流式布局** ###

​		流式布局（Liquid）的特点是页面元素的宽度不是固定的，而是按照屏幕分辨率进行适配调整，但整体布局没有发生改变。固定宽度布局使用的是像素，但是流体布局宽度使用的是百分比，但由于高度和文字大小神马还是使用的px所以会造成一旦两个分辨率差的有点大效果就差强人意。毕竟里面的文字是不会随着你窗口的减小跟着变小的。这也是早期屏幕分辨率相差不大时最爱用的。

　　网页中主要的划分区域的**尺寸使用百分数**（搭配min-*、max-*属性使用），例如，设置网页主体的宽度为80%，min-width为960px。图片也作类似处理（width:100%, max-width一般设定为图片本身的尺寸，防止被拉伸而失真）。

#### 1. 布局特点

　　屏幕分辨率变化时，页面里元素的大小会变化而但布局不变。【这就导致如果屏幕太大或者太小都会导致元素无法正常显示。

#### 2. 设计方法

　　**使用%百分比定义宽度，高度大都是用px来固定住**，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。

​		**这种布局方式在Web前端开发的早期历史上，用来应对不同尺寸的PC屏幕**（那时屏幕尺寸的差异不会太大），**在当今的移动端开发也是常用布局方式**，但**缺点明显**：**主要的问题**是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。因为宽度使用%百分比定义，但是高度和文字大小等大都是用px来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调。



### 绝对定位布局 ###

即传统Web设计，网页上的所有元素的尺寸一律使用px作为单位。

#### 1、布局特点

　　不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的pc的网站都是静态（定宽度）布局的，也就是设置了min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见于pc端。

#### 2、设计方法

　　**PC：**居中布局，所有样式使用绝对宽度/高度(px)，设计一个Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分；
　　**移动设备：**另外建立移动网站，单独设计一个布局，使用不同的域名如wap.或m.。



​		**优点**：这种布局方式对设计师和CSS编写者来说都是最简单的，亦没有兼容性问题。

​		**缺点**：显而易见，即不能根据用户的屏幕尺寸做出不同的表现。当前，大部分门户网站、大部分企业的PC宣传站点都采用了这种布局方式。固定像素尺寸的网页是匹配固定像素尺寸显示器的最简单办法。但这种方法不是一种完全兼容未来网页的制作方法，我们需要一些适应未知设备的方法。



### 流式布局与绝对定位布局比较 ###

​		固定布局优点：能够精准完成设计，不管是图文混排还是一行中文字长度的限制都是比较容易的。

​		**适用场景**

- 弹出框

- 右上角的关闭按钮

  

​		流式布局：灵活，充分利用浏览器的空间，相比固定布局，避免另一半空白，显得更好平衡。流式布局缺点是我们无法精确判断行长，页面布局以及元素位置。

​		**适用场景**

- 展示文本框



​		